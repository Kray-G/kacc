const KACC_LEXER_STATE_INITIAL = 'INITIAL';
const KACC_LEXER_STATE_EOF = -1;
const KACC_LEXER_SKIP = -2;

namespace Kacc {

class Lexer {

    var cur_ = KACC_LEXER_STATE_INITIAL;
    var inited_ = [];
    var states_ = [];
    var keywords_ = [];
    var text_, pos_ = 0;

    public addStateRule(name, pattern, token, action) {
        if (token.isFunction && action.isUndefined) {
            action = token;
            token = null;
        }
        if (!name.isString) {
            throw RuntimeException("State name should be a string.");
        }
        var callback = action.isFunction ? action : null;
        if (token.isUndefined && action.isInteger) {
            token = action;
        }
        var state = { pattern, callback, token };
        states_[name] ??= [];
        states_[name].push(state);
        return state;
    }

    public addRule(pattern, token, action) {
        return addStateRule(KACC_LEXER_STATE_INITIAL, pattern, token, action);
    }

    public addStateSkip(state, pattern) {
        return addStateRule(state, pattern, KACC_LEXER_SKIP);
    }

    public addSkip(pattern) {
        return addStateRule(KACC_LEXER_STATE_INITIAL, pattern, KACC_LEXER_SKIP);
    }

    public addStateKeyword(state, word, token) {
        if (!state.isString) {
            throw RuntimeException("State name should be a string.");
        }
        keywords_[state] ??= [];
        keywords_[state][word] = token;
    }

    public addKeyword(word, token) {
        return addStateKeyword(KACC_LEXER_STATE_INITIAL, word, token);
    }

    public reset(text) {
        cur_ = KACC_LEXER_STATE_INITIAL;
        inited_.keySet().each { => inited_[_1].reset = false };
        text_ = text;
        pos_ = 0;
    }

    public setState(state) {
        cur_ = state;
    }

    public $(state) {
        cur_ = state;
    }

    private scan(states, yylval) {
        for (var { pattern, callback, token } in states) {
            pattern.setPosition(pos_);
            if (pattern.find() && (found = pattern.group[0]).begin == pos_) {
                pos_ = found.end;
                yylval.value = found.string;
                if (callback.isFunction) {
                    if (token.isUndefined) {
                        return callback(yylval, this);
                    }
                    yylval.value = callback(yylval.value, this);
                }
                return token;
            }
        }
        return text_[pos_++];
    }

    public yylex(yylval) {
        var states = states_[cur_];
        if (!states) {
            throw RuntimeException("Invalid state of '%{cur_}'.");
        }
        if (!inited_[cur_].reset) {
            inited_[cur_].reset = true;
            if (!inited_[cur_].initialized) {
                inited_[cur_].initialized = true;
                var keywords = keywords_[cur_];
                if (keywords.isObject) {
                    var keys = keywords.keySet().sort(&(e1, e2) => e2.length() <=> e1.length());
                    states.unshift({
                        pattern: new Regex("(" + keys.join(")|(") + ")"),
                        callback: &(value) => keywords[value] ?? KACC_LEXER_STATE_EOF,
                    });
                }
            }
            for (var { pattern } in states) {
                pattern.reset(text_);
            }
        }
        if (pos_ < text_.length()) {
            var r;
            do {
                r = scan(states, yylval);
            } while (r == KACC_LEXER_SKIP);
            return r;
        }
        return KACC_LEXER_STATE_EOF;
    }

}

} // namespace Kacc
